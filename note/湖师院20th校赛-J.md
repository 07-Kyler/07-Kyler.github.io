# 题目：[华容道 ](http://172.20.8.83/problem.php?id=3113)

代码：[vscode-华容道](file:///d%3A/VS%20Code/c/prectice/2026/1.7zjhu20thcontest/j.cpp)
分析：![[3113华容道.docx]]
**标签：** #bfs
## 题意描述

华容道（或称数字拼图、八数码问题）是一个经典的益智游戏。在一个 3×3 的棋盘上，摆放着标号为 1 至 8 的八块正方形滑块，剩下的一个格子是空位。玩家可以移动与空位相邻（上下左右）的滑块进入空位，从而改变棋盘的布局。游戏的目标是通过一系列移动，将滑块恢复到有序的状态。  
  
给定一个 3×3 棋盘的初始状态，请你计算将其还原为目标状态所需的**最小操作次数**。  
  
目标状态定义如下：  
```
1 2 3
4 5 6
7 8 0
```

0：表示空位


**输入**

输入包含 3 行，每行包含 3 个由空格隔开的字符。其中数字 1-8 表示滑块，字符 0 表示空位。

**输出**

如果可以还原，输出一个整数，表示最少的操作次数。  

如果无论如何移动都无法还原到目标状态，请输出 -1。

----
## 题面翻译

算最小还原步数

---

## 解题思路

bfs题 重点是怎么存下每一次交换后的状态的步数 

应该清楚 这一题并不是要真的模拟一个棋盘上得每一步的状态 太麻烦了 

把每一个二维状态按序转换成一个一维的字符串 依次表示二维数组中的顺序并且用unordered_map存放每一个状态（字符串）的搜索层数

while循环里：
每一次先取出队首 出队
判断一下队首是不是答案
若不是答案则进入位移循环 只要不越界就是合法位移 就可以根据位移下标计算出一维下标（$nidx = nowx*3+nowy$）这里乘的是列数 ） 

注意这里每一次位移都要定义一个跟原来取出来的字符串相同的字符串用来交换字符进行状态转移 不能直接用while开头取出的cur字符串 因为当前取出的字符串的0位置可能会因为直接交换而改变 
这样导致后面的0基准位置变了 位移的位置就会出问题 所以一定要重新定义一个新的字符串用来存放交换后的字符串

交换的下标就是0的一维下标 和位移下标 交换完了之后就会形成一个新的状态

为了防止有一些循环在两个点之间来回走死循环 所以在每一次准备更新dis之前先判断当前字符串的键对应的值是否存在过了 只有不存在的情况才能更新

但是这里的un_map判断是有隐患的 必须要用find()函数严格查找是否存在 直接给一个键判断的话如果不符合if的条件 就会进入else语句污染本来已经记录过的值 （虽然这一题的属性导致每一次都会触发这个隐患但是刚好跟初始化的值重叠了所以侥幸过了 具体看代码注释）

详细分析坑 见[[unordered_map]]

最后如果while循环搜索完了还是没有找到答案就输出-1

---


${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

/*
先把初始状态按照字符串读进来
初始状态的dis设为0 记为0步
初始状态入队
队列非空 进入while循环
    队首出队
    找0的下标 算出二维坐标
    二维坐标经过四次位移先看看有没有碰壁 
    当前状态合法 计算0四周的坐标的下标
    初始状态复制一份用来存放新的字符串
    0和位移到的坐标上的字符swap
    新状态入队 dis设为上一步+1
*/
int wx[] = {-1,0,1,0};
int wy[] = {0,1,0,-1};
 
queue<string> q;
string s,t;
string sta = "123456780";

int main (){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    unordered_map<string,int> dis;
    for(int i = 0;i<9;++i){
        cin>>t;
        s+=t;
    }
    if(s == sta){
        cout<<0<<endl;
        return 0;
    }
    q.push(s);
    dis[s] = 0;
    while(!q.empty()){
        string curs = q.front();
        int d = dis[curs];
        q.pop();
        if(curs == sta){
            cout<<d<<endl;
            return 0;
        }
        
        int idx = curs.find('0');
        int nx = idx/3;
        int ny = idx%3;
        //这里因为每一个方向的交换都应该是用原来没用过的这个队首所以在循环里复制
        for(int i = 0;i<4;++i){
            string nows = curs;//每一个方向都复制一份当前状态用来移动
            int nowx = nx+wx[i];
            int nowy = ny+wy[i];
            if(nowx>2 || nowx<0 || nowy>2 || nowy<0)continue;
            int nidx = nowx*3+nowy;
            swap(nows[idx],nows[nidx]);
            
            //判断是否走过用下面这个代码 严格查找键是否存在 这里如果不存在会返回迭代器:dis.end()
            //每一个方向都进行判断 第一个判断成功的就是步数最少的答案
            if(dis.find(nows) == dis.end()){
                dis[nows] = d+1;
                q.push(nows); 
            }
            
            
            
            //这里的代码在now键不存在的时候会生成一个now键并且把值赋为0
            //有一定隐患 但是好像这道题没什么关系因为每一个值都是不严格递增的不会在后面出现值= 0 的情况被else分支污染
            //这里之所以可以通过是因为每一次找到一个新键都会触发这个隐患 把新键的值设置为0但是这刚好符合了我初始化为0的期望
            //后面再通过进入else语句来给这个键赋值 所以在这道题里面这个隐患没有体现出来
            //真正有隐患的题型是：我已经算过一个键的值就是0 但是我又重新带着一个非0的值走回这个键 发现0!=0为false 进入else污染了我原来正确的值0
            //===============错误写法=======================
            // if(dis[nows]!=0){//判断是否走过了
            //     continue;
            // }else{
            //     dis[nows] = d+1;
            //     q.push(nows);    
            // }
            //=============================================
        }
    }
    cout<<-1<<endl;
    return 0;

}
```