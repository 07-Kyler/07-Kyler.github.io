# 题目:[[USACO05FEB] 进击的奶牛 Aggressive Cows G](https://www.luogu.com.cn/problem/P1824)

**标签：** #二分 #贪心
## 题意描述

一座有 n 间牛舍的小屋，牛舍排在一条直线上，第 i 间牛舍在 $x_i$​ 的位置，但是这 m 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？

【数据范围】：对于 100% 的数据，2≤n≤105，0≤$x_i$​≤109，2≤m≤n。不保证 x 数组单调递增。

----
## 题面翻译

给定n间牛舍和m头牛 牛舍在小屋中的位置不固定 而是由数据给出 且数据也不一定有序 要在给定的这些牛舍中选择出m间牛舍放牛 使得两头牛之间的距离的最小值在所有的放法中是最大的 

---

## 解题思路

看到了*最大最小值* 大概率是一道 [[二分]]答案 二分可能的最大距离 带入到牛舍的距离中看看能不能满足 根据情况逐步逼近最佳答案  

但是！要看到给出的牛舍坐标不保证是单调的 而check函数的判断标准应该是遍历每两个牛舍之间的距离去跟mid比较 所以需要先把给定的牛舍坐标排序 保证每一次遍历到的两个牛舍都是相邻的（不是因为二分所以排序 是因为需要计算相邻的牛舍的距离才排序 本身二分并不是在二分牛舍 只是在找距离）

【二分范围】： 最大长度应该是排序之后的首牛舍和尾牛舍的我距离之差 最小长度应该是1（相邻的情况）

【check函数】：（bool 类型 ）每一次拿到一个可能的答案 $mid$ 都要遍历所有牛棚 如果当前牛舍与上一个牛舍的距离足够 那么维护 $last$ (表示上一个被选入牛舍的坐标的变量) 且累加当前已经选入的牛的数量 $cnt$   不需要显式的跳过语句 只要当前没有存下这个牛舍有牛的信息  就相当于跳过当前牛舍  在每一轮循环中都判断当前的选入牛数量是否达标 若没达标继续 达标了返回真 如果全部遍历完了也没有返回 $True$  那就是放不下了返回 $False$

【二分模板】：
写的时候还不太了解二分的几个模板用的是这个不太需要考虑是否会被边界卡死的模板：

```cpp
int l = 1,r = niushe[n-1]-niushe[0];
int ans;
while (l <= r){
	int mid = (l+r)/2;
	if(check(mid)){
		l = mid+1;
		ans = mid;
	}
	else{
		r = mid-1;
	}
}
```

但其实用下面这个更加常用的模板也可以：

```cpp
while (l < r){
	int mid = (l+r+1)/2;
	if(check(mid)){
	   l = mid;
	ans = mid;
	}
	else{
		r = mid-1;
	}
}
```

---------------

${{\Huge Code}}$
```cpp
//p1824


#include<bits/stdc++.h>
using namespace std;

int n,m;
bool check(int x);
vector<int> niushe;//存放小屋里每一个牛舍的位置

int main (){
    cin>>n>>m;
    niushe.resize(n);
    for(int i = 0;i<n;++i){
        cin>>niushe[i];
    }
    sort(niushe.begin(),niushe.end());//先要二分先要把数列变成有序的

    int l = 1,r = niushe[n-1]-niushe[0];//因为最大距离就是牛舍长度剩下的距离只能小于牛舍长度，所以二分对象是牛舍的长度
    int ans;
    while (l <= r){
        int mid = (l+r)/2;
        if(check(mid)){
            l = mid+1;//可以放得下就把左端点变成中值右一位继续向更大的数判断
            ans = mid;
        } 
        else{
            r = mid-1;//放不下就判断更小的数
        } 
    }
    
    //also:
    /*while (l < r){
		int mid = (l+r+1)/2;
		if(check(mid)){
		   l = mid;
		ans = mid;
		}
		else{
			r = mid-1;
		}
    }*/
    
    cout<<ans<<endl;
}
bool check(int dif){
    int last = 0;//记录上一个放牛的位置   初始化为0号位
    int cnt = 1;//因为第一头牛必定放一号位所以数量从1开始记
    for(int i=1; i<n; i++){
        if(niushe[i]-niushe[last]>=dif){//判断距离是不是大于二分出来的最小距离
            last = i;//维护上一次的位置信息
            cnt++;//放牛个数+1
            if(cnt >= m) return 1;//放的下了立马返回真
        }
    }
    
    return 0;
}
```