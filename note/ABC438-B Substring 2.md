# 题目：[Substring 2](https://atcoder.jp/contests/abc438/tasks/abc438_b)

**标签：** #字符串枚举 #最小代价问题
## 题意描述

给定一个长度为 N 的数字字符串 S 一个长度为 M 的数字字符串 T。  
这里的“数字字符串”指的是仅由数字 0 到 9 组成的字符串。

你可以进行以下操作任意次（也可以不做）：

- 从字符串 T 中选择一个字符，将该字符对应的数字加 1；
- 如果该数字是 9，则加 1 后变为 0（即对 10 取模）


请你求出：最少需要多少次操作，才能使得字符串 T 成为字符串 S 的一个子串（连续子序列）

----
## 题面翻译

S是大串 T是小串 要将小串中的任意位置修改任意次使其成为S中的一个子串

---

## 解题思路

这个题是找到一个区间内的字符串满足一定条件 可以考虑枚举大串中所有长度为M的子串 计算小串修改成这个子串需要的次数是多少 用mn记录所有次数的最小值  

这个题目中修改的方式是每一次+1所以对于每一个位置上的字符 修改次数就是与子串对应位置的差值 

为了规避负数取模计算的风险 每一次算出次数后+10再%10 

---


${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
string s,t;
int lens,lent;

int main (){
    cin>>n>>m;
    cin>>s>>t;
    int mn = 100000;//记录找到的最小次数
    for(int i = 0;i<=n-m;++i){//遍历所有子串的起点
        int cnt = 0;//记录当前次数
        for(int j = 0;j<m;++j){//遍历每一个子串的元素
            cnt+=(s[i+j]-t[j]+10)%10;
        }
        if(cnt<mn)mn = cnt;
    }
    cout<<mn;
    return 0;



}
```