# 题目：[星际拦截]([P3102 - 星际拦截 - ZJHUOJ](http://172.20.8.83/problem.php?id=3102))

**标签：** #二分答案 #前缀和 #pair
## 题意描述

星际防御系统监测到 n 个高能晶体碎片正在高速逼近母星。为了保卫家园，你需要操作一门高能激光炮将它们逐一击碎。

雷达扫描到了第 i 个碎片的两个参数:

1. 耐久度 $m_i$ ​: 击碎该碎片所需的能量总量。
2. 撞击时刻 $t_i$ ​: 该碎片撞击母星的时刻（从 0 时刻开始计数）。

激光炮拥有一个可调节的输出功率 P（P 为正整数）。击碎一个碎片所需的时间由物理公式决定:
$$\Huge{耗时 = [\frac{m_i}{P} ]}$$
即 $m_i$ ​除以 P 并向上取整。

拦截规则如下:

1. 激光炮在同一时刻只能攻击一个碎片。
2. 你可以任意安排攻击顺序，但必须连续照射直到当前碎片破碎，才能攻击下一个。
3. 系统从 0 时刻启动。对于第 i 个碎片，必须在ti​时刻或之前将其击碎（即完成时刻≤ $t_i$ ​），否则拦截失败。

功率 P 越大，能耗越高，且过载风险越大。为了确保安全，请计算：能够成功拦截所有碎片的**最小输出功率 P** 是多少？

如果无论功率多大都无法拦截所有碎片，请输出 - 1。

**输入格式:**

第一行包含一个整数n$(1≤n≤2×10^5)$，表示碎片数量。

接下来的 n 行，每行包含两个整数$m_i$​和$t_i$​($1≤m_i​,t_i​≤10^9)$，分别表示碎片的耐久度和撞击时刻。



----
## 题面翻译

先把激光炮的故事全部抽象掉：
- 有 n 个任务
- 每个任务 i：
    - 处理时间：$$\Huge{p_{i}(P) = [\frac{m_i}{P} ]}$$
    - 截止时间（deadline）：$$\Huge{d_{i} = t_{i}​}$$
- 只有一台机器
- 任务不可中断 
- 要求所有任务 ：完成时间 ≤ 各自 deadline

---

## 解题思路

看到是尽量找到最小 所以是二分答案+验证

 每一个碎片都有一个最晚摧毁时间限制$t_{i}$ 对于一个P 只要存在i∈n 在处理时累计的总时间晚于$t_{i}$ 那么就说明当前P就太小了 二分更大的范围 反之全部通过了就二分更小的范围

对于处理任务的顺序采取EDF顺序 即将任务按照截至时间升序排序 

EDF 是“可行性完备的”：  若存在任意可行调度，则 EDF 也一定可行。所以选择用EDF调度保证不漏解

如果存在一个可行解 使得处理两个相邻的 未按照截止时间升序排列的任务时的结果成立  那么交换两个任务的处理顺序也一定成立 且不会有任何一个任务超时
所以最优摧毁顺序一定是按照摧毁时间升序排列

因为有两个属性需要绑定排序 所以用pair存数组 pair默认先以first为关键词排序

对于无解情况 
1. $m_{i}$ 最大只能到 $10^9$  且 $m_{i}>0$
2. 耗时计算公式的最小值为1（当$p>m_{i}$时，p再取更大也不会影响耗时的值为1) 因为要向上取整 
3. 无解情况一定是前面所有P都返回0 左边界一直往大数方向推 最后找到了P为无限大∞ 此时的耗时最少也需要一个单位时间（小数也会向上取整到1）
4. 最后因为while的条件不满足了迫不得已退出循环 但是依旧是找到答案的 所以最后验证check(r) == 1？即可知道是否找到了最大答案

无解相当于即使我有一个无限大功率的机器 但是我的周围围了无数个碎片 且每一个都靠的极近 但我每摧毁一个碎片保底都需要1个单位时间 基于这两点条件 就一定会失败

样例：
	n = 3
	(m, t):
	(1, 1)
	(1, 1)
	(2, 2)

---

${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int maxn = 2e5+5;
vector<pair<int,int>> x(maxn);
vector<int>pre (maxn,0);
int n;

bool check(int p){
    int cost = 0;
    for(int i = 1;i<=n;++i){
        cost = (x[i].second+p-1)/p;  //这里不要用ceil 数据比较大
        if(cost+pre[i-1]>x[i].first){
            pre.clear();
            return 0;
        }else{
            pre[i] = pre[i-1]+cost;
        }
    }
    pre.clear();
    return 1;

}

signed main (){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    pre[0] = 0;
    cin>>n;
    for(int i = 1;i<=n;++i){
        cin>>x[i].second>>x[i].first;
    }
    sort(x.begin()+1,x.begin()+n+1);

    int l = 0,r = 1e9+1;
    while(l<r){
        int mid = l+r >> 1;
        if(check(mid))r = mid;
        else l = mid+1;
    }
    cout<<(check(r)? l:-1);
    return 0;



}
```

---
# 拓展

- 先抛出一个问题:
>为什么这题的解决顺序是按照撞击时间升序排列？

### 问题模型：**单机不可抢占调度**


设有一组任务集合  

$\mathcal{J} = \{1,2,\dots,n\}$

每个任务 $( i \in \mathcal{J} )$具有以下属性：

- 处理时间（processing time）：
 > $p_i > 0$
- 截止时间（deadline）：
>  $d_i > 0$
  

系统满足以下约束条件：

1. **单处理器（Single Machine）**：任意时刻最多处理一个任务  
2. **不可抢占（Non-preemptive）**：一旦开始执行某个任务，必须连续执行直至完成  

---

## EDF（Earliest Deadline First）调度定义

**定义（EDF，Earliest Deadline First）：**

> 在任意决策时刻，从所有尚未完成的任务中，  
> 选择 **截止时间最早（最小 $d_i$ ）** 的任务执行，  
> 并持续执行该任务直到完成。

在不可抢占模型下，该策略等价于：

> 将所有任务按照截止时间  $d_i$ 的非降序排序，  
> 并依次顺序执行。

---
### EDF 的可行性完备性

**定理（EDF 可行性完备性）：**

在单机、不可抢占调度模型中 : $$\exists \text{ 可行调度 } S\quad \Longrightarrow \quad\text{EDF 调度是可行的}$$
即：

> 如果存在任意一种调度方案能够使所有任务在各自截止时间之前完成，  
> 那么按照 EDF 顺序调度也一定可以完成所有任务。

---

### 对二分答案的意义

由于 EDF 具有可行性完备性：

> 在二分枚举功率  P  时，  
> 只需在 EDF 顺序下检查是否能在所有截止时间前完成任务，  
> 即可正确判定该  P  是否可行，而不会遗漏最优解。

---


那么既然EDF顺序这么强 自然就采用这种处理顺序保证不漏解
