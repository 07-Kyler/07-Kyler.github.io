# 题目：[C - 2026](https://atcoder.jp/contests/abc439/tasks/abc439_c)

**标签：** #反向思维 #数学模拟
## 题意描述

当一个正整数 n 满足以下条件时，称其为*好整数*：

存在*恰好一对*整数 (x,y)，满足 0<x<y **且** $x^2+y^2=n$。

例如，当 n=2026 时，可以验证 (x,y)=(1,45) 是唯一满足 0<x<y 且 $x^2+y^2=2026$ 的整数对。因此，2026 是一个好整数。

给定一个正整数 N，请列出所有不超过 N 的好整数。

数据范围：
- $1≤N≤10^7$
- N is an integer.

----
## 题面翻译

不在赘述

---

## 解题思路

这里的数据范围是1e7 如果对于一个数直接用双层循环遍历所有结果一定会超时

而且可以看到 小于N的数判断是否为好整数的方法都是相同的 只需要满足（存在 *恰好一对* 整数 (x,y)，满足 0<x<y **且** $x^2+y^2=n$。） 那么我不妨将满足条件看作是计算公式来算出所有好整数

利用反向思维 将N看作是一个约束条件 我只需要大致算出所有小于N的所有好整数 最后遍历输出小于N的所有数即可

其中为了满足有且仅有一对x y能表示当前好整数 用桶来标记当前好整数被表示过多少次 如果最后桶中值等于1 就说明是一个好整数 被多次表示的标记为-1

还需注意 题目要求 $x<y$  则通过表达式可以得出当 x = i ($x<\sqrt{n}$) 时 , $i < j < \sqrt{n-i*i}$ .

桶多开一点防止越界

---


${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
vector<int> bin;

int main (){
    cin>>n;
    bin.resize(n+10,0);
    int cnt = 0;
    for(int i = 1;i<=sqrt(n);++i){
        for(int j = i+1;j<=sqrt(n-i*i);++j){
            int t = i*i+j*j;
            if(bin[t] == 1){
                bin[t] = -1;
            }else if(bin[t] == 0){
                bin[t] = 1;
            }
        }
    }
    for(int i = 1;i<=n;++i){
        if(bin[i] == 1)cnt++;
    }
    cout<<cnt<<endl;
    for(int i = 1;i<=n;++i){
        if(bin[i]==1)cout<<i<<' ';
    }
    return 0;
} 
```