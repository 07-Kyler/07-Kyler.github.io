# 题目：[P1570 KC 喝咖啡](https://www.luogu.com.cn/problem/P1570)

**标签：** #分数规划 #二分答案 #表达式变形
## 题意描述

KC 想要喝一杯咖啡,现在有 $n$ 种调料，这杯咖啡只可以加入其中的 $m$ 种（当然 KC 一定会加入 $m$ 种，不会加入少于 $m$ 种的调料），根据加入的调料不同，制成这杯咖啡要用的时间也不同，得到的咖啡的美味度也不同。

KC 在得知所有的 $n$ 种调料后，知道了所有调料消耗的时间 $c _ i$ 以及调料的美味度 $v _ i$。由于 KC 急着回去刷题，所以他想尽快喝到这杯咖啡，但他又想喝到美味的咖啡，所以他想出了一个办法，他要喝到 $\dfrac{\sum v _ i}{\sum c _ i}$ 最大的咖啡，也就是单位时间的美味度最大的咖啡。

----
## 题面翻译

给定整数m,n：
n表示可选元素的数量，从中选出m个元素，每一个元素都有对应的两种属性-$v_i$ $c_i$，求$\dfrac{\sum v _ i}{\sum c _ i}$的最大值.

## 解题思路

$\dfrac{\sum v _ i}{\sum c _ i}$这个东西看起来就是 #分数规划 ，题目的目标是求这个表达式的最大值 但是这个分式相当于上下两部分都是变量 不好直接求 所以我不直接求最大值 而是用[[二分]]的方法逼近这个最大值 又因为我想要找最大 所以这个二分出来的值 $mid$ 应该满足：$$\frac{\sum v_i}{\sum c_i} \geq mid$$
这样我就能知道这个表达式的最大值至少是 $mid$ 这么大，反之则应该用二分缩小$mid$

但是这个表达式恶心在他要的是在n项元素中找出**最优的**m个元素之后才能判断当前表达式能不能满足（<u>如果不找到最优解 可能会因为漏掉当前本来能满足条件的这个mid导致答案错误</u>）

鉴于这种窘境 我们就可以考虑通过移相的方式来让这个表达式变得好计算 经过移相表达式变成：$$mid *{\sum c_i} - {\sum v_i}\geq0$$

可以看到对于固定的一个mid和两个数组c,v 这个表达式就变成了关于i的一个方程  令 :$$ w[i] = mid *{c_i} - {v_i}$$（*check函数的思路如下*)那么我只需要在每一次二分出一个mid的时候 循环n次 计算出新的“贡献数组”w的所有值再从大到小排序 选出其中的m个最大贡献值的数进行累和就可以 再将这个累和的数与0做比较 


${\Huge Code}$

```cpp
// //p1570


#include<bits/stdc++.h>
using namespace std;

  
int n,m;
int v[205],c[205];
double w[205];  //这里注意新的数组不一定是整数 所以用double
  
bool check(double mid);
  
int main (){
    cin>>n>>m;
    for(int i = 1;i<=n;++i){
        cin>>v[i];
    }
    for(int i = 1;i<=n;++i){
        cin>>c[i];
    }
    //二分可能的最大值
    double l = 0,r = 1005;
    //这里精度要求三个点 但是在四个小数点的情况下是不够用的 所以用5个小数点
    while(r-l > 0.000001){
        long double mid = (l+r)/2.0;
//！浮点二分答案坑点：因为是小数点逼近答案所以维护边界的时候不用+-1 否则会跳过很大一部分的数值
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%.3f",l);
    return 0;
}
bool check(double mid){
    //计算新的贡献数组
    for(int i = 1;i<=n;++i){
        w[i] = v[i]-mid*c[i];
    }
    //从大到小排序
    sort(w+1,w+1+n);
    reverse(w+1,w+1+n);
    double sum = 0.0;
    //取前面最大的m个数值累和求出当前w数组的最优解
    for(int i = 1;i<=m;++i){
        sum+=w[i];
    }
    return sum>=0;
}
```
-----
以下是错误思路————DFS搜索

${\Huge False Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
int v[205];
int c[205];
double mx = 0.0;
//此处用了dfs的算法
void dfs (int idx,int cnt,double sumc,double sumv);
signed main (){
    cin>>n>>m;
    for(int i = 1;i<=n;++i){
        cin>>v[i];
    }
    for(int i = 1;i<=n;++i){
        cin>>c[i];
    }
    dfs(1,0,0,0);
 
    printf("%.3f",mx);
    return 0;
}
//dfs的目标是搜索所有可能的组合 计算并记录最大值
void dfs (int idx,int cnt,double sumc,double sumv){
    if(cnt>m) return;
    if(idx>n) return;
    if(cnt == m && sumc!=0){
        double cur = sumv/sumc;//当前的计算值
        mx = max(mx,cur);
    }
 
    //选
    dfs(idx+1,cnt+1,sumc+c[idx],sumv+v[idx]);
    //不选
    dfs(idx+1,cnt,sumc,sumv);
}
```


我觉得这题可以用“选或不选”的思路做 但是没有考虑到时间复杂度($2^{n}$)
导致直接炸缸了T_T

下次应该先看一下数据范围再根据想到的算法计算一下时间复杂度（O）














