# 题目：[New Year String](https://codeforces.com/contest/2182/problem/A)

**标签：** #字符串枚举 #最小代价问题
## 题意描述

我们把只包含字符 0、2、5 和 6 的字符串称作 <u>新年字符串</u>，条件是它至少满足下面两个条件中的一个：

- 包含连续子串 2026；
- 不包含连续子串 2025。

举个例子，字符串 20252026、21026、20262026、000 都是新年字符串。而字符串 2025、20256、20252025、000202500020226 就不是新年字符串。

现在给你一个字符串 ss，你可以进行如下操作任意次（包括零次）：

- 选择字符串 ss 中的一个字符，将它替换成 0、2、5 或 6 中的任意一个。

请你计算，使字符串 ss 变成新年字符串所需的最少操作次数。



----
## 题面翻译

对于给定的字符串 每一次可以选取字符串中的任意一个字符修改 计算将该字符串修改为新年字符串的最小次数


---

## 解题思路

对于一个字符串 只需要满足两个条件的其中一个就是新年字符串 但是我不知道应该以哪个条件为最终目标的修改次数是最优的 所以我就应该对于每一个字符串分别计算达成这两个条件的次数 取二者较小值即为最优解

- 包含连续子串 2026：这个条件的表意是只需要满足存在一个2026即可 那么我可以用长度为4的窗口枚举每一个子串 计算将当前的子串改成2026的次数 用mn记录改动的最小次数（注意 这里不是真的将原来的字符串改动 枚举之后原来的字符串是不会变动的 只是计算了改动所需要花的次数）

- 不包含连续子串 2025：不包含要求的是整个字符串中不包含2025 也是遍历所有长度为4的子串 找到所有2025 并且任意改动其中一个字符就可以破坏2025 
	
	- 对于<u>当前子串改动是否会影响到相邻子串</u>的问题的分类讨论：
		
		- 改\[0]位置 相邻子串一定是 025x 不会是2025
		- 改\[1]位置 相邻子串就是 x25x 也不会是2025
		- 改\[2]位置 相邻子串就是 0x5x 显然不会是2025
		- 改\[3]位置 相邻子串就是 02xx也不会是2025
	
	- 满足2025的条件是\[0]\[2]位置为2
	- 但是当枚举到下一个子串的时候\[1]位置是2 所以一定不能形成2025子串
	
	- 综上数学验证 找到了2025子串 随便修改破坏即可 不会导致相邻子串变为2025 使次数增加

	对于这个条件需要计算的就是对于大字符串 破坏掉每一个2025子串需要的次数 也就是2025子串的个数 计算出个数就是满足条件2的一个解

最后取两种方法的最小值 即为答案

---


${{\Huge Code}}$
```cpp
#include <bits/stdc++.h>
using namespace std;

int t,n;
string x;

void solve(){
    cin>>n;
    cin>>x;
    
    int mn1 = 10000;
    for(int r = 3;r<n;++r){//遍历每一串长度为4的子串
        int l = r-3;
        int t1 = 0;
        //判断当前字符串
        if(x[l] != '2') t1++;
        if(x[l+1] != '0')t1++;
        if(x[l+2] != '2')t1++;
        if(x[l+3] != '6')t1++;
        if(t1<mn1)mn1 = t1;
    }
    int t2 = 0;
    for(int r = 3;r<n;++r){//遍历每一串长度为4的子串
        int l = r-3;
        if(x[l] == '2' && x[l+1] == '0' && x[l+2] == '2' && x[l+3] == '5'){
            t2++;
        }
        
    }
    int ans = min(mn1,t2);
    cout<<ans<<endl;
    return ;
}

int main (){
    cin>>t;
    while(t--){
        solve();
    }
    return 0;


```