# 题目：[Striped Horse](https://atcoder.jp/contests/abc440/tasks/abc440_c)

**标签：** #公式变形 #滑动窗口 #前缀和
## 题意描述

Ringo-san 正在给一匹马涂上条纹，使它看起来像一只斑马。

有 N 个格子，从 1 到 N 按顺序排成一行。  
一开始，所有格子都是白色的。  
将第 i 个格子涂成黑色的代价是 $C_i$。

现在只允许 执行一次 如下的操作来给部分格子涂成黑色：

自由选择一个正整数 x；    
对所有满足  $${1\leq i \leq N  }$$ 
且  $$(i + x) \bmod (2W) < W $$ 
的格子 i，将其涂成黑色。

请你求 执行这一次操作所需的**最小总代价**。

---

## 题面翻译

抽象题意得关键就在于这个表达式：$(i + x) \bmod (2W) < W$ 

以2W为一个周期压缩数组 x为偏移量 找到一个长度为w的区间计算区间的贡献

x就相当于在这个2W的区间内你可以选择起点 为x 后面再跟随i的递增选取W长度的位置涂黑

---
## 解题思路

经过观察可以发现<u> (i+x)%2w 的值和(i+x+2w)%2w的值是相同的</u> 固定一个x 那么这些位置的格子都会被染黑 

所以可以把原来的数组以2W为循环下标 压入一个长度为2W的数组中 %2W余数相同的格子消耗都相加成为一个新的格子

这个新的数组的下标就是原来数组的下标%2w的结果∈\[0,2w-1] 先抛开x不谈 也就是我要在这个余数中选取一段下标满足 $0\leq i< w$  这个区间决定了满足这个条件的下标一定是连续的 （这个区间暂且称为窗口） 而这个窗口内的坐标我需要用一个量来表示 所以题目中引用了$i$  再加上x来看对于每一个i 加上一个x 不就相当于是偏移了x个位置 又因为这个x是我们自己决定的 这就奠定了这道题用滑动窗口的基础  

因为是求区间和 自然能想到用前缀和的方法记录和的值

因为x的取值是随便取的（即使在代码实现的时候的x取值是根据循环变量而定的）但是真正有效的x取值是在 0 - 2W-1 （所以在代码中只需要考虑有效下标以内的x的取值 也就是在数组内部滑动即可）所以如果x取得比较大的时候会被2W约束会范围 但是这时候就不是x值本身了 而是余数（可能会落在一个比较小的位置上） 在数组中体现的就应该是分布于首尾的物理上相隔开的两小段区间 

分隔两小段这种结构 就应该考虑环状结构来实现 只要在计算出来的新数组后面再复制一份一模一样的循环数组就能实现循环

至于为什么需要复制的数组长度是而不是整个长度2w ：
	假设现在有一个经过计算后的新数组 1 2 3 4   
	显然w = 2 那么所有可能的区间就是：
	`1 2`
	`2 3`
	`3 4`
	`4 1`
	最后一组区间`4 1`就是要考虑的问题 因为再往后循环的话就会回到`1 2`
	显而易见的我只需要这个数组的前w-1的长度就可以形成一个完整的环状结构即数组数据为 `1 2 3 4 1`这样按照滑动窗口的思路就可以覆盖到每一个连续或非连续的长度为w的区间
	！这里还要注意 复制的范围应该是前w-1的长度
	也就是最后的数组长度应该为3w-1

因为有多组测试数据 需要用`x.assign(n, 0);`语句在设置大小的时候严格清空上一次的数据 



---


${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
int T,n,w;
vector<int> x,c,pre;

void solve(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>w;
    x.assign(n, 0);
    c.assign(4*w, 0);
    pre.assign(4*w + 1, 0);//resize 后面跟的填入内容是不会直接清空原来的数据的 这个可以
    for(int i = 0;i<n;++i){
        cin>>x[i];
    }
    for(int i = 0;i<n;++i){
        int idx = (i+1)%(2*w);
        c[idx]+=x[i];
    }
    for(int i = 0;i<2*w;++i){
        c[i+2*w] = c[i];
    }
    
    
    for(int i = 0;i<4*w;++i){
        pre[i+1]+=pre[i]+c[i];
    }
    int mn = LLONG_MAX;
    for(int r = w-1;r<=3*w-1;++r){
        int l = r-w+1;
        int sum = pre[r+1]-pre[l];
        if(sum<mn){
            mn = sum;
        }
    }
    cout<<mn<<endl;
    return ;

}

signed main (){
    cin>>T;
    while(T--){
        solve();
    }
    return 0;
}
```