# 题目：[P2390 地标访问](https://www.luogu.com.cn/problem/P2390)

**标签：** #二分答案
## 题意描述

贝西在一条道路上旅行，道路上有许多地标，贝西想要在日落之前访问尽可能多的路标。贝西每分钟可以移动一单位距离。

将道路视为一条数轴，贝西从原点出发，道路上有 n(1≤n≤5×1e4) 个地标，每个地标有一个坐标 $x_i​$ ( $∣x_i​∣$ ≤105) 且地标的坐标各不相同，t(1≤t≤1e9) 分钟之后将会日落。

----
## 题面翻译
一条数轴上有n个坐标（给出时间距不规律） 总共有t步可以走求能访问到的最大坐标数 


---

## 解题思路

因为题目要找的是最大值 考虑用二分+验证的方法来解

既然是二分地标数量 那就要保证被二分的数是有序的 所以读入后先要给地标排序

因为求的是地表的最大值 而且按照常理来讲t是一定要用完才能找到最大值的 相当于t是固定数 每一次二分一个可能的地标数（相当于一个区间）而且这道题抽象出来就是要找到一个区间符合给定的一个条件 那么我二分出来了一个区间长度 我就需要再枚举所有这个长度的区间来验证符合不符合 自然而然就能想到用双指针来标定区间 其中枚举右边界 左边界就等于右边界-长度 在枚举过程中找到一个区间满足就可以返回真 二分更大的地标个数 

注意这里遍历的只是连续存储的坐标的下标 并不是坐标在数轴上的位置

【疑惑】：按照访问效率最高的情况来说原点左右的两个地标应该是一定要被访问的 因为访问更远的地标的时候一定会遍历到这个地标 访问这个地标即没有增加时间又增加了已访问的地标数 对于二分的趋势是更有利的 为什么有时候找到的区间是在原点很远的地方呢？

对于这个问题首先要明确 二分和check函数分别负责的职责：

**二分**  ： 负责找到尽可能大的一个满足条件的地标数
**check**：只负责判断当前传入的地标数能不能符合条件

所以疑惑中的情况一般是出现在t很大 传入的地标数又很小的情况 可以浪费很多步数到很远的地方访问一小段坐标 最后依旧能在t步之内访问到要求的地标数 又因为遍历是从地标数组的最左边向右遍历的 所以在二分的刚开始 出现这样的情况是极有可能的 不过因为后面二分的进一步优化 能被浪费掉的步数减少 符合条件的区间自然而然的会更加靠近原点 

应该清楚所有效率最高的路径<u>一定是先走一侧直接走到头再回头走另一侧 </u>否则就会有一定的步数浪费在中间的来回路径中

代码中注释不重要^\_^

---


${{\Huge Code}}$
```cpp
//p2390


#include<bits/stdc++.h>
using namespace std;
int t,n;
vector<int> a(1000005);
bool check(int count);

int main (){
    cin>>t>>n;
    a.resize(n);
    for(int i = 0;i<n;++i){
        cin>>a[i];
    }
    sort(a.begin(),a.begin()+n);
    //二分可能的地标数
    int l = -1,r = n+1;
    while(l+1<r){
        int mid = (l+r+1)/2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    cout<<l<<endl;
    return 0;


}
//传入一个这一次需要走的地标数
//枚举这个地标数下的所有区间长度
//最后与t相比 大于t说明t步内走不了这么多缩小 小于就说明还可以走更多的地标
//因为check函数的功能！！只是判断当前这么多的地标数能不能被在t时间内访问完！！
//所以为了严格维护这种情况的地标数是可以跳过连续区间外面的一些节点直接访问区间的边界的
//!注意这里遍历的只是连续存储的坐标的下标 并不是坐标在数轴上的位置

bool check(int x){
    for(int r = x-1;r<n;++r){
        int l = r-x+1;
        if(a[r]<=0){
            if(-a[l]<=t) return 1;
        }
        if(a[l]>=0){
            if(a[r]<=t) return 1; 
        }
        if(a[r]>0 && a[l]<0){
            if((min(a[r],-a[l])+a[r]-a[l])<=t) return 1;
        } 
    }                  
    return 0;                  
    
}
```