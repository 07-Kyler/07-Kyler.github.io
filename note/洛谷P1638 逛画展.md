# 题目：[P1638 逛画展](https://www.luogu.com.cn/problem/P1638)

**标签：** #滑动窗口 #双指针 #桶
## 题意描述

m位画家办画展 共有n幅画 （n>m)

游客在购买门票时必须说明两个数字，x 和 y，代表他要看展览中的第 x 幅至第 y 幅画（包含 x,y）之间的所有图画，而门票的价钱就是一张图画一元。

游客希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。

求出他购买门票时应选择的 x,y。

若存在多组解，输出 x 最小的那组。

----
## 题面翻译

一共有打乱顺序的n幅画 找出一个最小区间 \[x-y] ( y-x>=m ) 使得区间内至少有每一个画家的一幅画  

---

## 解题思路

好像可以先二分再滑动窗口 但是没有直接滑动窗口快 所以就直接写滑动窗口

总共维护四个边界变量 l  r  ans_l  ans_r    其中lr是动态的维护变量 ans_l  ans_r是当找到可行的答案之后再更新 维护一个覆盖变量 cover 用来记录当前这个区间内已经右多少画家的画  

关键 ：用[[桶]]记录现在的区间内有哪些画家的多少幅画 每进出一个画家都要判断更新

循环条件 ：循环到右边界到头了就停止 即 $while(right<n)$ 因为左边界是在循环内部维护的 右边界到头了一定不会再变了 最后的维护也只能是在最后一次循环中维护左边界 

循环内部 ：只要当前画的数量没有满足就右边界右移一次 如果桶内数字为0 说明当前画家的画是新被覆盖到的 cover++ 判断是否满足只要满足了左边界循环右移并维护答案边界变量 直到画的数量不满足条件左边界停止右移 在左边界右移的过程中每次都要将桶中的当前出去的画家的画数量-- 如果刚好减为0了 相当于区间内少了一个画家 cover-- 从而退出左边界右移的循环 

【可能的疑惑】为什么在左边界右移的时候可以将某一个画家的所有画全部移除呢  ？
因为如果不找到一个画家并且移除他的所有画 就一直满足 $cover == m$ 的条件 就会一直左边界右移 而且这么做的目的是看看后面有没有更加短的区间 所以要舍弃现在区间的某一个画家 

---


${{\Huge Code}}$
```cpp
#include<bits/stdc++.h>
using namespace std;

// bool check(int l,int r);
int n,m;
int ans_x,ans_y;
vector<int> p;
vector<int> bin;

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin>>n>>m;
    ans_x = 1;
    ans_y = n;
    p.resize(n);//p装所有画的分布
    bin.resize(m,0);//统计当前区间内画家的画的数量
    
    for(int i = 0;i<n;++i){
        cin>>p[i];
        p[i]--;//为了跟桶的下标对齐所以画家的编号全部--
    }
    
    int left = 0,right = 0;
    int cover = 0;
    int len  = n+1;

    while(right<n){//这里因为是 0~based 所以是<
        if(cover<m){//还没找到满足的区间 right右移
            if(bin[p[right]] == 0){//桶里还没有当前画家 记录&覆盖++
                cover++;
            }
            bin[p[right]]++;
            right++;
        }
        while(cover == m){
            if(right-left<len){
                ans_x = left;
                ans_y = right;
                len  = right-left;
            }
            bin[p[left]]--;
            if(bin[p[left]] == 0){
                cover--;
            }
            left++; 
        }
        
    }
    
    cout<<ans_x+1<<" "<<ans_y<<endl;
    return 0;

    
}


```